from rest_framework.views import exception_handler
from rest_framework.exceptions import status
from django.utils.translation import gettext_lazy as _
from rest_framework.exceptions import APIException

import logging

logger = logging.getLogger(__name__)


class RecordAlreadyExist(APIException):
    status_code = status.HTTP_400_BAD_REQUEST
    default_detail = _('Record already exist.')
    default_code = 'record_already_exist'


class NotInChoices(APIException):
    status_code = status.HTTP_400_BAD_REQUEST
    default_detail = _('Not in choice.')
    default_code = 'not_in_choice'


def _handle_generic_error(exc, context, response):
    """
    一般
    """
    response.data = {
        "errors": response.data
    }
    return response

def core_exception_handler(exc, context):
    # If an exception is thrown that we don't explicitly handle here, we want
    # to delegate to the default exception handler offered by DRF. If we do
    # handle this exception type, we will still want access to the response
    # generated by DRF, so we get that response up front.
    response = exception_handler(exc, context)

    handlers = {}
    # This is how we identify the type of the current exception. We will use
    # this in a moment to see whether we should handle this exception or let
    # Django REST Framework do it's thing.
    exception_class = exc.__class__.__name__

    if isinstance(exc, APIException):
        return _handle_generic_error(exc, context, response)

    elif exception_class in handlers:
        # If this exception is one that we can handle, handle it. Otherwise,
        # return the response generated earlier by the default exception
        # handler.
        return handlers[exception_class](exc, context, response)
    else:
        logger.warning('Unknown exception type!')
        return _handle_generic_error(exc, context, response)



